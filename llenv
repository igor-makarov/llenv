#!/usr/bin/env node
"use strict";

const { readFileSync, existsSync } = require("fs");
const { spawnSync } = require("child_process");
const { join } = require("path");
const { homedir } = require("os");

const CONFIG_FILE = process.env.LLENV_CONFIG || join(homedir(), ".llenv", "config.json");

function die(msg) {
  process.stderr.write(`llenv: ${msg}\n`);
  process.exit(1);
}

function loadConfig() {
  let raw;
  try {
    raw = readFileSync(CONFIG_FILE, "utf8");
  } catch {
    die(`config not found: ${CONFIG_FILE}`);
  }
  try {
    return JSON.parse(raw);
  } catch {
    die(`invalid JSON in ${CONFIG_FILE}`);
  }
}

function interpolateValue(val) {
  if (typeof val !== "string") return val;
  return val.replace(/\$\{([^}]+)\}|\$([A-Za-z_][A-Za-z0-9_]*)/g, (_, braced, bare) => {
    const name = braced || bare;
    return process.env[name] ?? "";
  });
}

function interpolateEnv(vars) {
  const result = {};
  for (const [k, v] of Object.entries(vars)) {
    result[k] = interpolateValue(v);
  }
  return result;
}

function resolveEnv(config, name) {
  const envs = config.envs;
  if (!envs || typeof envs !== "object") die("config missing \"envs\" object");
  if (name) {
    if (!envs[name]) die(`env "${name}" not found in config`);
    return interpolateEnv(envs[name]);
  }
  if (config.defaultEnv) {
    if (!envs[config.defaultEnv]) die(`default env "${config.defaultEnv}" not found in config`);
    return interpolateEnv(envs[config.defaultEnv]);
  }
  const envKeys = Object.keys(envs);
  if (envKeys.length === 0) die("no environments in config");
  return interpolateEnv(envs[envKeys[0]]);
}

function usage() {
  process.stdout.write(`Usage: llenv [--env <name>] <command> [args...]

Apply environment variables from a config before launching a command.

Config: ${CONFIG_FILE}

Options:
  --env <name>   Use a named env from config (default: defaultEnv or first entry)
  --list         List available environments
  --show <name>  Print resolved env vars without running a command
  --help         Show this help

Examples:
  llenv --env ollama claude
  llenv npm start
  llenv --list
`);
  process.exit(0);
}

function listEnvs() {
  const config = loadConfig();
  const envs = config.envs;
  if (!envs || typeof envs !== "object") die("config missing \"envs\" object");
  const defaultName = config.defaultEnv;
  const keys = Object.keys(envs);
  if (keys.length === 0) die("no environments in config");
  console.log(`Environments in ${CONFIG_FILE}:`);
  for (const k of keys) {
    const isDefault = k === defaultName || (!defaultName && k === keys[0]);
    console.log(`  ${k}${isDefault ? " (default)" : ""}`);
  }
}

function showEnv(name) {
  const config = loadConfig();
  const env = resolveEnv(config, name);
  const resolved = name || config.defaultEnv || Object.keys(config.envs)[0];
  console.log(`Environment: ${resolved}`);
  for (const [k, v] of Object.entries(env)) {
    console.log(`  ${k}=${v}`);
  }
}

// Parse arguments
const args = process.argv.slice(2);
let envName = "";
let i = 0;

while (i < args.length) {
  const arg = args[i];
  if (arg === "--env") {
    if (i + 1 >= args.length) die("--env requires a name");
    envName = args[i + 1];
    i += 2;
  } else if (arg === "--list") {
    listEnvs();
    process.exit(0);
  } else if (arg === "--show") {
    showEnv(args[i + 1] || "");
    process.exit(0);
  } else if (arg === "--help" || arg === "-h") {
    usage();
  } else if (arg === "--") {
    i++;
    break;
  } else if (arg.startsWith("-")) {
    die(`unknown option: ${arg}`);
  } else {
    break;
  }
}

const cmd = args.slice(i);
if (cmd.length === 0) {
  process.stderr.write("llenv: no command specified\n");
  usage();
}

// Load env and exec
const config = loadConfig();
const env = resolveEnv(config, envName);

for (const [k, v] of Object.entries(env)) {
  process.env[k] = String(v);
}

const result = spawnSync(cmd[0], cmd.slice(1), {
  stdio: "inherit",
  env: process.env,
});

if (result.error) {
  if (result.error.code === "ENOENT") {
    die(`command not found: ${cmd[0]}`);
  }
  die(result.error.message);
}

process.exit(result.status ?? 1);
